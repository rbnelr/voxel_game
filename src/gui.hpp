
#include "imgui.h"

static Shader* shad_imgui;
struct Imgui_Vbo {
	GLuint						vbo_vert;
	GLuint						vbo_indx;
	
	void init () {
		glGenBuffers(1, &vbo_vert);
		glGenBuffers(1, &vbo_indx);
		
	}
	~Imgui_Vbo () {
		glDeleteBuffers(1, &vbo_vert);
		glDeleteBuffers(1, &vbo_indx);
	}
};
Imgui_Vbo imgui_vbo;

static void imgui_init () {
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO();
	
	Texture2D* font_atlas = new Texture2D;
	shad_imgui = new_shader("imgui.vert", "imgui.frag", {UCOM}, {{0,"atlas"}});
	
	imgui_vbo.init();
	{
		u8* pixels;
		s32 w, h;
		io.Fonts->GetTexDataAsRGBA32(&pixels, &w, &h);
		
		font_atlas->alloc_cpu_single_mip(PT_SRGB8_LA8, iv2(w,h));
		
		memcpy(font_atlas->mips[0].data, pixels, font_atlas->mips[0].size);
		
		font_atlas->upload();
		
		io.Fonts->TexID = (void*)font_atlas;
	}
}
static void imgui_destroy () {
    ImGui::DestroyContext();
}

static void imgui_begin (f32 dt, iv2 wnd_dim, iv2 mcursor_pos_px, bool lmb_down, bool rmb_down) {
	ImGuiIO& io = ImGui::GetIO();
	
	io.DisplaySize.x = (flt)wnd_dim.x;
	io.DisplaySize.y = (flt)wnd_dim.y;
	io.DeltaTime = dt;
	io.MousePos.x = (flt)mcursor_pos_px.x;
	io.MousePos.y = (flt)mcursor_pos_px.y;
	io.MouseDown[0] = lmb_down;
	io.MouseDown[1] = rmb_down;
	
	ImGui::NewFrame();
	ImGui::Begin("Global dev options", nullptr);
}

static bool option_group (strcr name, bool* open=nullptr) {
	return false;
}

static bool option (strcr name, bool* val, bool* open=nullptr) {
	return ImGui::Checkbox(name.c_str(), val);
}
static bool option (strcr name, s32 (*get)(), void (*set)(s32)=nullptr, bool* open=nullptr) {
	return false;
}
static bool option (strcr name, s32* val, bool* open=nullptr) {
	return ImGui::DragInt(name.c_str(), val);
}
static bool option (strcr name, s64* val, bool* open=nullptr) {
	return false;
}
static bool option (strcr name, u64* val, bool* open=nullptr) {
	return false;
}
static bool option (strcr name, f32* val, bool* open=nullptr) {
	return ImGui::DragFloat(name.c_str(), val);
}
static bool option (strcr name, v2* val, bool* open=nullptr) {
	return false;
}
static bool option (strcr name, v3* val, bool* open=nullptr) {
	return false;
}

static bool option_deg (strcr name, f32* val, bool* open=nullptr) {
	return false;
}
static bool option_deg (strcr name, v2* val, bool* open=nullptr) {
	return false;
}

static void draw_imgui (iv2 wnd_dim) {
	ImGui::End();
	ImGui::Render();
	
	if (!shad_imgui->valid()) return;
	
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE);
	glEnable(GL_SCISSOR_TEST);
	
	shad_imgui->bind();
	shad_imgui->set_unif("screen_dim", (v2)wnd_dim);
	
	ImDrawData* draw_data = ImGui::GetDrawData();
	
	struct Imgui_Vertex {
		v2		pos_screen;
		v2		uv;
		u32		col;
	};
	
	glBindBuffer(GL_ARRAY_BUFFER, imgui_vbo.vbo_vert);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, imgui_vbo.vbo_indx);
	
	GLint pos_loc =	glGetAttribLocation(shad_imgui->prog, "pos_screen");
	GLint uv_loc =	glGetAttribLocation(shad_imgui->prog, "uv");
	GLint col_loc =	glGetAttribLocation(shad_imgui->prog, "col");
	
	glEnableVertexAttribArray(pos_loc);
	glVertexAttribPointer(pos_loc, 2, GL_FLOAT, GL_FALSE, sizeof(Imgui_Vertex), (void*)offsetof(Imgui_Vertex, pos_screen));
	
	glEnableVertexAttribArray(uv_loc);
	glVertexAttribPointer(uv_loc, 2, GL_FLOAT, GL_FALSE, sizeof(Imgui_Vertex), (void*)offsetof(Imgui_Vertex, uv));
	
	glEnableVertexAttribArray(col_loc);
	glVertexAttribPointer(col_loc, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(Imgui_Vertex), (void*)offsetof(Imgui_Vertex, col));
	
	for (int n = 0; n < draw_data->CmdListsCount; n++) {
		auto* cmd_list = draw_data->CmdLists[n];
		
		const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
		const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
		
		auto vertex_size = cmd_list->VtxBuffer.size() * sizeof(ImDrawVert);
		auto index_size = cmd_list->IdxBuffer.size() * sizeof(ImDrawIdx);
		
		glBufferData(GL_ARRAY_BUFFER, vertex_size, NULL, GL_STREAM_DRAW);
		glBufferData(GL_ARRAY_BUFFER, vertex_size, vtx_buffer, GL_STREAM_DRAW);
		
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, index_size, NULL, GL_STREAM_DRAW);
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, index_size, idx_buffer, GL_STREAM_DRAW);
		
		const ImDrawIdx* cur_idx_buffer = idx_buffer;
		
		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++) {
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback) {
				pcmd->UserCallback(cmd_list, pcmd);
			} else {
				bind_texture_unit(0, (Texture2D*)pcmd->TextureId);
				
				flt y0 = (flt)wnd_dim.y -pcmd->ClipRect.w;
				flt y1 = (flt)wnd_dim.y -pcmd->ClipRect.y;
				
				
				
				glScissor((int)pcmd->ClipRect.x, y0, (int)(pcmd->ClipRect.z -pcmd->ClipRect.x), (int)(y1 -y0));
				
				// Render 'pcmd->ElemCount/3' indexed triangles.
				// By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits if your engine doesn't support 16-bits indices.
				glDrawElements(GL_TRIANGLES, pcmd->ElemCount, GL_UNSIGNED_SHORT,
					(GLvoid const*)((u8 const*)cur_idx_buffer -(u8 const*)idx_buffer));
			}
			cur_idx_buffer += pcmd->ElemCount;
		}
	}
	
	glScissor(0,0, wnd_dim.x,wnd_dim.y);
	
	glDisable(GL_SCISSOR_TEST);
	glEnable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
}
