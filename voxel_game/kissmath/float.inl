// file was generated by kissmath.py at <TODO: add github link>

////// Inline definitions

namespace kissmath {
	
	// wrap x into range [0,range)
	// negative x wrap back to +range unlike c++ % operator
	// negative range supported
	inline float wrap (float x, float range) {
		float modded = std::fmod(x, range);
		if (range > 0) {
			if (modded < 0) modded += range;
		} else {
			if (modded > 0) modded += range;
		}
		return modded;
	}
	
	// wrap x into [a,b) range
	inline float wrap (float x, float a, float b) {
		x -= a;
		float range = b -a;
		
		float modulo = wrap(x, range);
		
		return modulo + a;
	}
	
	// returns the greater value of a and b
	inline constexpr float min (float l, float r) {
		return l <= r ? l : r;
	}
	
	// returns the smaller value of a and b
	inline constexpr float max (float l, float r) {
		return l >= r ? l : r;
	}
	
	// equivalent to ternary c ? l : r
	// for conformity with vectors
	inline constexpr float select (bool c, float l, float r) {
		return c ? l : r;
	}
	
	// clamp x into range [a, b]
	// equivalent to min(max(x,a), b)
	inline constexpr float clamp (float x, float a, float b) {
		return min(max(x, a), b);
	}
	
	// clamp x into range [0, 1]
	// also known as saturate in hlsl
	inline constexpr float clamp (float x) {
		return min(max(x, float(0)), float(1));
	}
	
	inline float wrap (float x, float a, float b, int* quotient) {
		x -= a;
		float range = b -a;
		
		float modulo = wrap(x, range);
		*quotient = floori(x / range);
		
		return modulo + a;
	}
	
	
	// floor and convert to int
	inline int floori (float x) {
		return (int)floor(x);
	}
	
	// ceil and convert to int
	inline int ceili (float x) {
		return (int)ceil(x);
	}
	
	// round and convert to int
	inline int roundi (float x) {
		return std::lround(x);
	}
	
	
	//// Angle conversion
	
	
	// converts degrees to radiants
	inline constexpr float to_radians (float deg) {
		return deg * DEG_TO_RAD;
	}
	
	// converts radiants to degrees
	inline constexpr float to_degrees (float rad) {
		return rad * RAD_TO_DEG;
	}
	
	// converts degrees to radiants
	// shortform to make degree literals more readable
	inline constexpr float deg (float deg) {
		return deg * DEG_TO_RAD;
	}
	
	// converts degrees to radiants
	// spcial shortform to make degree literals more readable and allow to use integer literals (deg(5) would throw error)
	inline constexpr float deg (int deg) {
		return (float)deg * DEG_TO_RAD;
	}
	
	// linear interpolation
	// like getting the output of a linear function
	// ex. t=0 -> a ; t=1 -> b ; t=0.5 -> (a+b)/2
	inline constexpr float lerp (float a, float b, float t) {
		return t * (b - a) + a;
	}
	
	// linear mapping
	// sometimes called inverse linear interpolation
	// like getting the x for a y on a linear function
	// ex. map(70, 0,100) -> 0.7 ; map(0.5, -1,+1) -> 0.75
	inline constexpr float map (float x, float in_a, float in_b) {
		return (x - in_a) / (in_b - in_a);
	}
	
	// linear remapping
	// equivalent of lerp(out_a, out_b, map(x, in_a, in_b))
	inline constexpr float map (float x, float in_a, float in_b, float out_a, float out_b) {
		return lerp(out_a, out_b, map(x, in_a, in_b));
	}
	
	//// Various interpolation
	
	
	// standard smoothstep interpolation
	inline float smoothstep (float x) {
		float t = clamp(x);
		return t * t * (3.0f - 2.0f * t);
	}
	
	// 3 point bezier interpolation
	inline float bezier (float a, float b, float c, float t) {
		float d = lerp(a, b, t);
		float e = lerp(b, c, t);
		float f = lerp(d, e, t);
		return f;
	}
	
	// 4 point bezier interpolation
	inline float bezier (float a, float b, float c, float d, float t) {
		return bezier(
					  lerp(a, b, t),
					  lerp(b, c, t),
					  lerp(c, d, t),
					  t
			   );
	}
	
	// 5 point bezier interpolation
	inline float bezier (float a, float b, float c, float d, float e, float t) {
		return bezier(
					  lerp(a, b, t),
					  lerp(b, c, t),
					  lerp(c, d, t),
					  lerp(d, e, t),
					  t
			   );
	}
	
	
	// length(scalar) = abs(scalar)
	// for conformity with vectors
	inline float length (float x) {
		return std::fabs(x);
	}
	
	// length_sqr(scalar) = abs(scalar)^2
	// for conformity with vectors (for vectors this func is preferred over length to avoid the sqrt)
	inline float length_sqr (float x) {
		x = std::fabs(x);
		return x*x;
	}
	
	// scalar normalize for conformity with vectors
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>
	// can be useful in some cases
	inline float normalize (float x) {
		return x / length(x);
	}
	
	// normalize(x) for length(x) != 0 else 0
	inline float normalizesafe (float x) {
		float len = length(x);
		if (len == float(0)) {
			return float(0);
		}
		return x /= len;
	}
	
}

