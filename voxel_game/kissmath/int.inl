// file was generated by kissmath.py at <TODO: add github link>

////// Inline definitions

namespace kissmath {
	
	// wrap x into range [0,range)
	// negative x wrap back to +range unlike c++ % operator
	// negative range supported
	inline int wrap (int x, int range) {
		int modded = x % range;
		if (range > 0) {
			if (modded < 0) modded += range;
		} else {
			if (modded > 0) modded += range;
		}
		return modded;
	}
	
	// wrap x into [a,b) range
	inline int wrap (int x, int a, int b) {
		x -= a;
		int range = b -a;
		
		int modulo = wrap(x, range);
		
		return modulo + a;
	}
	
	// returns the greater value of a and b
	inline constexpr int min (int l, int r) {
		return l <= r ? l : r;
	}
	
	// returns the smaller value of a and b
	inline constexpr int max (int l, int r) {
		return l >= r ? l : r;
	}
	
	// equivalent to ternary c ? l : r
	// for conformity with vectors
	inline constexpr int select (bool c, int l, int r) {
		return c ? l : r;
	}
	
	// clamp x into range [a, b]
	// equivalent to min(max(x,a), b)
	inline constexpr int clamp (int x, int a, int b) {
		return min(max(x, a), b);
	}
	
	// clamp x into range [0, 1]
	// also known as saturate in hlsl
	inline constexpr int clamp (int x) {
		return min(max(x, int(0)), int(1));
	}
	
	
	// length(scalar) = abs(scalar)
	// for conformity with vectors
	inline int length (int x) {
		return std::abs(x);
	}
	
	// length_sqr(scalar) = abs(scalar)^2
	// for conformity with vectors (for vectors this func is preferred over length to avoid the sqrt)
	inline int length_sqr (int x) {
		x = std::abs(x);
		return x*x;
	}
	
	// scalar normalize for conformity with vectors
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>
	// can be useful in some cases
	inline int normalize (int x) {
		return x / length(x);
	}
	
	// normalize(x) for length(x) != 0 else 0
	inline int normalizesafe (int x) {
		int len = length(x);
		if (len == int(0)) {
			return int(0);
		}
		return x /= len;
	}
	
}

