DONE:
 
 collision not working properly on corners
 -> fixed, was a normalization of zero vector that caused nan
 -> 2nd. bug: needed to do raycasting on minowski sum of 5 blocks not 3
 
 implement collision in 3d
 implemented jumping
 
 implemented outlined block highlighting
 
 block placing
 
 block abient occulusion (AO)
 
 fix collision bug
 somtimes can still get stuck on the border of blocks when jumping
 -> i did not calculate the radius test correctly on raycasting with top and bottom of minowski sum
     so the collision was just not detected sometimes
 
 reimplement nice terrain with new noise function
 
 added water
 
 added imgui to replace my own dev/debug gui
 
 added basic tree generation
 -> uses a tree density noise layer
 -> tries to avoid trees being too close to each other by scaling the tree spawn propbablity based on how close other already spawned tress are (this is tree spawn order dependant, but that is deterministic with our method)
 
 add trees
  -RNG seeded by chunk pos
  -generate random chance for each xy block column
  -calculate tree chance via tree desity noise layer
  -spawn tree if random chance is above tree chance
  -maybe check if there already are trees nearby and dont spawn it in that case
 
 remove my own dev/debug gui and reimplement the Immediate mode option code with imgui controls
 -remember to remove redundant stb text libs from deps/
 -clean up unused shaders from shaders/
 -add viewing of any texture in imgui window
 
 added alpha for leaves texture and toggable graphics option that disables alpha for leaves (and does also not generate the invisible faces, since this is to improve performance on low power machines)
 
 make sure movement code is framerate independent, the lerp(old_vel, desired_vel, alpha) is framrate dependant
 -I did like the feel of the movement on 60 fps
  -> maybe plot speed via imgui and screenshot it
  -> and then develop new movement code with better force based movement that closely matches that curve
 
 check if the atlas filtering works like it should, i think I see atlas bleeding happening currently
 -do we use mipmaps?
 -maybe do use mipmaps but put special code in the fragment shader that clamps the uvs to never filter outside the tile?
 -> Switched to texture arrays, no bleeding possible
 -> using nearest for mag and linear_mipmap_linear for min with alias 16
 
 factor out all the drawing code too, and either just manually do all the gl things "manually"
  or add real abstractions for gl
  -> maybe actually follow the "factor into function if similar code appears 3+ times" rule
      ie. just stupidly type out all required code and then see what gets repeated
  the main loop should probably never know about textures at all, just graphics.draw_world(); for p in players: graphics.draw_player(p) etc.
  and the graphics class handles all the stuff itself, this way it can decide if it wants the textures to have it's own class
 -> factored out drawing code into a bunch of *Graphics classes that are responsible for drawing and keep all texture shader etc. state
 -> created some sensible opengl abstractions, but some stuff is still missing and there could potentially be WAY less code
     if i just followed my own advice and just wrote down all the opengl code by hand and then factored things out into functions as i went
     I guess i just don't like doing that in opengl, because i like turning glGen* and glDelete* into automatic ctors dtors
  
 crosshair
 
 port all player code to player class
 -factor out all the relevant raycast, physics etc. code into their own utility files
 -player physics should maybe be handled outside player class by a physics manager that later ensures that there are not wierd order dependencies between players and npcs
 
 imgui console log
 
 view frustrum colling of chunk drawcalls
 
 merge current sound code
 
 add inventory
 -inventory gui
 
 completely multithread code

 now storing a border of one voxel around each chunks voxel data to completely remove any need to do neighbour chunk lookups when needing neighbour voxels (one block far only obviously)
 -this requires keeping track of these copied blocks since the border blocks now are duplicated.
 -but doing so required about the same amount of code as the neighbour lookups were requiring before and this should allow way batter performance
   since a lot of conditionals now just go away in the bulk voxel operations like remeshing and light propagation
   which speed up the code, since only changed blocks need to be updated in neighbours and only if they are border blocks, this overhead is minimal and constant time.
 -this already sped up the remeshing from ~2.5ms to 1.5ms, and the constant offsets might give another boost

light propagation and even meshing might even be simd-ized now since we can work with constant offsets for block neighbours and even compute shaders are not easier

light propagation using algorithm from https://www.seedofandromeda.com/blogs/29-fast-flood-fill-lighting-in-a-blocky-voxel-game-pt-1
-fixed wierd bugs that seem to have come from the fact that the queue in the algo was assuming the light level always reduces by 1 for each step, leaves and water reduce it by 2 in my case tho, which broke that assumption
-turning the queue into a priority queue seems to have fixed the problem completely (did thin on gut feeling, instead of rigorous analysis, will be ashamed if It turns out this is bugged too -_-)

TODO
-FEATURES:

 light propagation code
 -sunlight

 see if there are any obvious optimizations to be done for remeshing
 -remesh 'core' blocks first, then remesh outter shell (that touches neighbour chunks)
  -this way the shell can be remeshed if a neighbour changed without needing to remesh the core because we can save the offset of the shell meshes and overwrite those
  -core does not need to access neighbours so the whole query_block can go away and turn into a simple 3d array offset
  -4 chunk remeshes when changing a block touching 4 chunks are now 1 full remesh and 3 shell remeshes
 
 rework items to be classes with inheritance?
 -pro: might simplyfy code a lot
 -pro: complex state does not take up memory in union for simple items
 -con: now need pointers everywhere
 -con: saving now isn't a simple memcpy

 implement inventory gui that you can drag and drop

 implement block stack count, gain on break, lose on place

 write actual air control
 -no slowdown in air with wasd not pressed, press s to slow down when going forward
 -ie. apply accel not based on vel - desired_vel but directly from move dir, but clamped to a max speed
 -max speed set when starting jump? so that walk->jump->press sprint does not speed you up in the air, but sprint jump also does not slow you down
 -at least a little air control is needed to get up blocks when jumping while touching a block
 
 air drag to set max falling speed

 crouch walk to not fall off edges

 make better sprinting code
  sprinting should have a drawback over walking, or it just gets used all the time
   -> stamina?
   -> only allow forward, need to initiate sprint, when turning camera too quickly sprint stops
   -> bounce on collision with block? ie. when not timing jumps perfectly running up slopes
 
 add headbob?

 implement light level, night and torches
 
 sounds with openAL instead

 npcs

 debug mipmaps, they almost look like they are generated incorrectly, tree leaves look like they should be darker ?
 -maybe mipmaps can be modified manually to get less better aliasing in the distance, esp. with alpha blending

 -> collision system is still bugged in the current state even close to the origin at 144hz

 The epsilon is very finnicky,
 -it needs to be small enough to actually act like an epsilon (we teleport the player slightly above the ground and away from walls by this epsilon)
   if it is too big then gravity will not accelerate the player fast enough with my 144hz framerate too "reach" the ground fast enough so that suddenly the player only "touches" the ground every 3 frames
   and the position stutters slightly, which also trips up the grounded detection.
 -an epsilon should be close to the limit of float precision to avoid this.
   but it cannot be that small because then simply by moving 1000 blocks in one direction not the epsilon rounds to 0
   > not good
 -doubles would probably solve this issue even for far distances, but gpus do not support doubles usually so that is not an option
 -the only remaining solution is to have a "moving" origin, where the graphics and physics happens with these relative coords
   but the actual positions store an additional int to keep track of their real value
 -in this case of already having int indexes for blocks and floats for player, npcs etc. it is advantageous to just split the coords into block pos and fract pos with fract being a float
  -> floor(pos_world) reduces to pos_world.block > nice
  -> opengl matricies now need to store their coords relative to the player block, all block pos passed into shaders also need to get the player block substracted
  -> all fractional world positons need to use the new block_pos, fract_pos pair instead, which needs to wrap() its fract part and modify its block pos if the fract part moves wraps
  -> per frame you can simply work with this moving origin being constant, ie. use floats
   -> at the beginning of the frame a global block pos gets set as origin for that frame, coord->float just substracts that origin and float->coord adds it again,
      now this is almost automatic, you just need to make sure to not store float pos_worlds across frames because they get invalidated by the origin moving, just like an iterator into a vector gets invalidated by the vector expanding
 
 movement code in traditional way, ie. check for overlap and depen vector and apply collision response with these (teleport to depen)
 -can still split timestep based on movement speed to make sure teleporting through blocks does not happen
 -by enforcing a max movement speed we can be sure that we never infinite loop

 underwater fog

 reflections for water?
 -screenspace reflection
 
 look at COLLISION_SEPERATION_EPSILON, and if the raycast physics can live without it, being grounded should leave pos==block_top and vel.z==0

 even if getting stuck inside a block (which should be numerically impossible with a timestep of 0.05 as long as the integers are representable as floats (max would be 16,777,217))
  there should be a way of getting out of a block you are stuck in (since that should during gameplay), for example to fix being teleported into a wall or the ground
  allthough since you can break blocks, that might not be all that important
  getting out of deep inside a mountain should maybe not be possible
  but getting out of a wall you are only stuck in slightly should be possible
  maybe the physics does not let you enter blocks but once inside you get a force pushing you out and the collision does not stop you from exiting
  don't allow directed movement when in a wall or this might allow tunneling through walls
  a force might cause you to be flung away so the best way might just be:
   in the center of a block: stuck (no movement / "drowning" gameplay effect)
   you penetrate the wall by less than 0.5f block widths -> you are clearly on one side of the block, so just teleport you so you don't penetrate (player.pos -= pen_vector;)
   -> but only if the space you teleport to is free -> when stuck in completely solid rock you are stuck
 
 better third person camera object avoidance
 -camera should never clip into blocks! currently the camera focus point does not, but the near plane still goes into the block partly

 make a shader inspector in imgui that can edit shader code

 add shader directory change notify to reload all shaders that contain a changed file

IDEAS:
 voxel cone tracing for indirect lighting?
 -voxelize scene (no op for us, just need albedo for each voxel which is just it's avg texture color)
 -inject direct lighting -> torch light is already calculated in minecraft style light, sunlight should also be feasable even with a moving sun
 -filter down -> 8 voxels average down to 1 voxel to create "mipmaps", alpha could represent opacity
 -cone trace all surface faces
  -spawn a few cones at the surface, cone has a angle -> at dist x the radius is y -> sample the mipmap that best fits that radius
  -this way you prevent having N voxel samples for a NxNxN world, and instead have log N
  -the resulting sum of light now represent the indirect bounced light (just 1 bounce)
  -if that bounced light is now used as lighting of the voxel a second pass could add another bounce

 The only feasable way to render all chunks in one draw call i found is an extension for sparse vbos
 -allocate a vbo large enough for all possible chunks with each single face added in the mesh data
 -each chunk gets a slot in there
 -mesh data gets generated like usual, uploaded, the giant (100MB) slot for the chunk is mostly unused
 -but that is fine because the actual memory is virtualized and only the used pages are commited via the extension
 -indirect drawcalls can then be used to draw all the actual filled parts of the giant vbo

 Since the major terrain features are mostly based on the low noise frequencies, 1/2000m for ex.
  the noise function does not actually change by much from chunk to chunk, and since the amplitudes of these frequencies also dominate the result
  it should be possible to determine a min and max possible noise value for each chunk
  -you might be able to modify perlin noise or similar noise to actually return the minmax for a 3d volume, but that might be complicated
  -a trick i just thought of is to not actually use per block noise samples for the very low freqs but instead do one sample per chunk and then interpolate based on a chunk and it's neighbours
    this way the minmax should be 100% possible to calculate and fast too.
  -this might allow for correct 'culling' of chunks before they ever need to be generated in any way, which should allow to bring down the chunk count in a 3d chunk system from view_dist^3 to view_dist^2 (surface area instead of volume)

 explore ray marching for rendering:
 -no chunk meshes at all, gpu does ray marching
  -how is the complexity, performance and artifacting
 -feasable without octree?
  -performance difference with octree?
 -options: pixel shader, compute shader, opencl, cuda
  -> compute shader probably makes the most sense, but pixel shader might also be finde since i am basicly trying to display the image anyway
 -automatic order independent transparency!
 -reflections on water / glass

 instead of floating blocks everywhere create a basic structural simulation
 -minecraft proved that having large amounts of blocks be "falling blocks" (sand, eg. in desert) is possible
 -checks when blocks start falling just need to be limited
 -can this idea be extended to include checks along connected blocks, to see how "stable" they are?
 -stablity is at say 100 for fixed blocks and decreases for each block that is not fixed by some value depending on the block type
  (similar to how torch light falls off)
 -blocks with stablity 0 cannot be placed or just fall down (randomly maybe)
 -stablity could be visualized by having blocks "sag" with low stablity, ie. the mesher just shifts them down a bit
 -1 block wide towsers would still be 100% stable
  -maybe a noita-like system (the powder pixels) could be used so that falling blocks also randomly fall off the side of a block to form 






-OLD version:
 convert entire debug optios into new imgui way of doing things
 
 fix cut off trees
  -also do this for all 8 surrounding chunks no matter if the're generated or not
  -this way we can generate leaves in our chunks of trees in a neibouring chunk
 
 immediate mode debug shapes
 -arrow for velocity acceleration etc.
 -path drawing: object user can put outside of main loop -output one point each frame -> get line of last n points
 -> try to get rid of as much code in main loop as possible by turning player collision cylinder, etc. into code using this
 -maybe even integrate vector viewing into my imgui debug variables (allow visualizing any vector that gets displayed in the imgui)
 
 redesign input system
 
 improve block AO
 
 improve performance on notebook
 -chunk optimization ????
 
 blocks inventory (gain blocks on break and lose on place)
 
-BUGS:
