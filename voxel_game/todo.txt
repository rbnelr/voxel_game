DONE:
 
 collision not working properly on corners
 -> fixed, was a normalization of zero vector that caused nan
 -> 2nd. bug: needed to do raycasting on minowski sum of 5 blocks not 3
 
 implement collision in 3d
 implemented jumping
 
 implemented outlined block highlighting
 
 block placing
 
 block abient occulusion (AO)
 
 fix collision bug
 somtimes can still get stuck on the border of blocks when jumping
 -> i did not calculate the radius test correctly on raycasting with top and bottom of minowski sum
     so the collision was just not detected sometimes
 
 reimplement nice terrain with new noise function
 
 added water
 
 added imgui to replace my own dev/debug gui
 
 added basic tree generation
 -> uses a tree density noise layer
 -> tries to avoid trees being too close to each other by scaling the tree spawn propbablity based on how close other already spawned tress are (this is tree spawn order dependant, but that is deterministic with our method)
 
 add trees
  -RNG seeded by chunk pos
  -generate random chance for each xy block column
  -calculate tree chance via tree desity noise layer
  -spawn tree if random chance is above tree chance
  -maybe check if there already are trees nearby and dont spawn it in that case
 
 remove my own dev/debug gui and reimplement the Immediate mode option code with imgui controls
 -remember to remove redundant stb text libs from deps/
 -clean up unused shaders from shaders/
 -add viewing of any texture in imgui window
 
 added alpha for leaves texture and toggable graphics option that disables alpha for leaves (and does also not generate the invisible faces, since this is to improve performance on low power machines)
 
 make sure movement code is framerate independent, the lerp(old_vel, desired_vel, alpha) is framrate dependant
 -I did like the feel of the movement on 60 fps
  -> maybe plot speed via imgui and screenshot it
  -> and then develop new movement code with better force based movement that closely matches that curve
 
 check if the atlas filtering works like it should, i think I see atlas bleeding happening currently
 -do we use mipmaps?
 -maybe do use mipmaps but put special code in the fragment shader that clamps the uvs to never filter outside the tile?
 -> Switched to texture arrays, no bleeding possible
 -> using nearest for mag and linear_mipmap_linear for min with alias 16
 
 factor out all the drawing code too, and either just manually do all the gl things "manually"
  or add real abstractions for gl
  -> maybe actually follow the "factor into function if similar code appears 3+ times" rule
      ie. just stupidly type out all required code and then see what gets repeated
  the main loop should probably never know about textures at all, just graphics.draw_world(); for p in players: graphics.draw_player(p) etc.
  and the graphics class handles all the stuff itself, this way it can decide if it wants the textures to have it's own class
 -> factored out drawing code into a bunch of *Graphics classes that are responsible for drawing and keep all texture shader etc. state
 -> created some sensible opengl abstractions, but some stuff is still missing and there could potentially be WAY less code
     if i just followed my own advice and just wrote down all the opengl code by hand and then factored things out into functions as i went
     I guess i just don't like doing that in opengl, because i like turning glGen* and glDelete* into automatic ctors dtors
     
TODO
-FEATURES:
 
 port all player code to player class
 -factor out all the relevant raycast, physics etc. code into their own utility files
 -player physics should maybe be handled outside player class by a physics manager that later ensures that there are not wierd order dependencies between players and npcs
 
 code order:
	 for all players: player.controls_update(); // control look dir -> check grounded state -> control desired walk velocity, jump, crouch etc.
	 physics_manager.update_rigidbody_physics(); // rigidbody == the cylinder of players or the box of npcs, ie. update pos and vel using physics parameters (bounciness etc.) using the cylinder cast timestepping algo and afterwards potentially add seperation forces to force npcs/players apart
	 for all players: player.post_phys_update(); // position is final -> update camera positions, and do block placement / breaking with final rays (block placement should probably happen instantly, since order with block placing should not be important)
 
 look at COLLISION_SEPERATION_EPSILON, and if the raycast physics can live without it, being grounded should leave pos==block_top and vel.z==0

 even if getting stuck inside a block (which should be numerically impossible with a timestep of 0.05 as long as the integers are representable as floats (max would be 16,777,217))
  there should be a way of getting out of a block you are stuck in (since that should during gameplay), for example to fix being teleported into a wall or the ground
  allthough since you can break blocks, that might not be all that important
  getting out of deep inside a mountain should maybe not be possible
  but getting out of a wall you are only stuck in slightly should be possible
  maybe the physics does not let you enter blocks but once inside you get a force pushing you out and the collision does not stop you from exiting
  don't allow directed movement when in a wall or this might allow tunneling through walls
  a force might cause you to be flung away so the best way might just be:
   in the center of a block: stuck (no movement / "drowning" gameplay effect)
   you penetrate the wall by less than 0.5f block widths -> you are clearly on one side of the block, so just teleport you so you don't penetrate (player.pos -= pen_vector;)
   -> but only if the space you teleport to is free -> when stuck in completely solid rock you are stuck
 
 make better sprinting code
  sprinting should have a drawback over walking, or it just gets used all the time
   -> stamina?
   -> only allow forward, need to initiate sprint, when turning camera too quickly sprint stops
   -> bounce on collision with block? ie. when not timing jumps perfectly running up slopes
 
 add headbob?

 make a shader inspector in imgui that can edit shader code

 add shader directory change notify to reload all shaders that contain a changed file

 voxel cone tracing for indirect lighting?
 -voxelize scene (no op for us, just need albedo for each voxel which is just it's avg texture color)
 -inject direct lighting -> torch light is already calculated in minecraft style light, sunlight should also be feasable even with a moving sun
 -filter down -> 8 voxels average down to 1 voxel to create "mipmaps", alpha could represent opacity
 -cone trace all surface faces
  -spawn a few cones at the surface, cone has a angle -> at dist x the radius is y -> sample the mipmap that best fits that radius
  -this way you prevent having N voxel samples for a NxNxN world, and instead have log N
  -the resulting sum of light now represent the indirect bounced light (just 1 bounce)
  -if that bounced light is now used as lighting of the voxel a second pass could add another bounce

 The only feasable way to render all chunks in one draw call i found is an extension for sparse vbos
 -allocate a vbo large enough for all possible chunks with each single face added in the mesh data
 -each chunk gets a slot in there
 -mesh data gets generated like usual, uploaded, the giant (100MB) slot for the chunk is mostly unused
 -but that is fine because the actual memory is virtualized and only the used pages are commited via the extension
 -indirect drawcalls can then be used to draw all the actual filled parts of the giant vbo

-OLD version:
 convert entire debug optios into new imgui way of doing things
 
 fix cut off trees
  -also do this for all 8 surrounding chunks no matter if the're generated or not
  -this way we can generate leaves in our chunks of trees in a neibouring chunk
 
 immediate mode debug shapes
 -arrow for velocity acceleration etc.
 -path drawing: object user can put outside of main loop -output one point each frame -> get line of last n points
 -> try to get rid of as much code in main loop as possible by turning player collision cylinder, etc. into code using this
 -maybe even integrate vector viewing into my imgui debug variables (allow visualizing any vector that gets displayed in the imgui)
 
 redesign input system
 
 improve block AO
 
 view frustrum culling

 improve performance on notebook
 -chunk optimization ????
 
 blocks inventory (gain blocks on break and lose on place)
 
 work on gl abstraction
 
-BUGS:
