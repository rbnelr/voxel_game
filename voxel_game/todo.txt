DONE:
 
 collision not working properly on corners
 -> fixed, was a normalization of zero vector that caused nan
 -> 2nd. bug: needed to do raycasting on minowski sum of 5 blocks not 3
 
 implement collision in 3d
 implemented jumping
 
 implemented outlined block highlighting
 
 block placing
 
 block abient occulusion (AO)
 
 fix collision bug
 somtimes can still get stuck on the border of blocks when jumping
 -> i did not calculate the radius test correctly on raycasting with top and bottom of minowski sum
     so the collision was just not detected sometimes
 
 reimplement nice terrain with new noise function
 
 added water
 
 added imgui to replace my own dev/debug gui
 
 added basic tree generation
 -> uses a tree density noise layer
 -> tries to avoid trees being too close to each other by scaling the tree spawn propbablity based on how close other already spawned tress are (this is tree spawn order dependant, but that is deterministic with our method)
 
 add trees
  -RNG seeded by chunk pos
  -generate random chance for each xy block column
  -calculate tree chance via tree desity noise layer
  -spawn tree if random chance is above tree chance
  -maybe check if there already are trees nearby and dont spawn it in that case
 
 remove my own dev/debug gui and reimplement the Immediate mode option code with imgui controls
 -remember to remove redundant stb text libs from deps/
 -clean up unused shaders from shaders/
 -add viewing of any texture in imgui window
 
 added alpha for leaves texture and toggable graphics option that disables alpha for leaves (and does also not generate the invisible faces, since this is to improve performance on low power machines)
 
 make sure movement code is framerate independent, the lerp(old_vel, desired_vel, alpha) is framrate dependant
 -I did like the feel of the movement on 60 fps
  -> maybe plot speed via imgui and screenshot it
  -> and then develop new movement code with better force based movement that closely matches that curve
 
 check if the atlas filtering works like it should, i think I see atlas bleeding happening currently
 -do we use mipmaps?
 -maybe do use mipmaps but put special code in the fragment shader that clamps the uvs to never filter outside the tile?
 -> Switched to texture arrays, no bleeding possible
 -> using nearest for mag and linear_mipmap_linear for min with alias 16
 
 factor out all the drawing code too, and either just manually do all the gl things "manually"
  or add real abstractions for gl
  -> maybe actually follow the "factor into function if similar code appears 3+ times" rule
      ie. just stupidly type out all required code and then see what gets repeated
  the main loop should probably never know about textures at all, just graphics.draw_world(); for p in players: graphics.draw_player(p) etc.
  and the graphics class handles all the stuff itself, this way it can decide if it wants the textures to have it's own class
 -> factored out drawing code into a bunch of *Graphics classes that are responsible for drawing and keep all texture shader etc. state
 -> created some sensible opengl abstractions, but some stuff is still missing and there could potentially be WAY less code
     if i just followed my own advice and just wrote down all the opengl code by hand and then factored things out into functions as i went
     I guess i just don't like doing that in opengl, because i like turning glGen* and glDelete* into automatic ctors dtors
  
 crosshair
 
 port all player code to player class
 -factor out all the relevant raycast, physics etc. code into their own utility files
 -player physics should maybe be handled outside player class by a physics manager that later ensures that there are not wierd order dependencies between players and npcs
 
 imgui console log
 
 view frustrum colling of chunk drawcalls
 
 merge current sound code

TODO
-FEATURES:
 
 rethink tool animations

 add inventory
 -inventory gui

 write actual air control
 -no slowdown in air with wasd not pressed, press s to slow down when going forward
 -ie. apply accel not based on vel - desired_vel but directly from move dir, but clamped to a max speed
 -max speed set when starting jump? so that walk->jump->press sprint does not speed you up in the air, but sprint jump also does not slow you down
 -at least a little air control is needed to get up blocks when jumping while touching a block
 
 make better sprinting code
  sprinting should have a drawback over walking, or it just gets used all the time
   -> stamina?
   -> only allow forward, need to initiate sprint, when turning camera too quickly sprint stops
   -> bounce on collision with block? ie. when not timing jumps perfectly running up slopes
 
 add headbob?

 implement light level, night and torches
 
 sounds with openAL instead

 npcs

 debug mipmaps, they almost look like they are generated incorrectly, tree leaves look like they should be darker ?
 -maybe mipmaps can be modified manually to get less better aliasing in the distance, esp. with alpha blending

 The epsilon is very finnicky,
 -it needs to be small enough to actually act like an epsilon (we teleport the player slightly above the ground and away from walls by this epsilon)
   if it is too big then gravity will not accelerate the player fast enough with my 144hz framerate too "reach" the ground fast enough so that suddenly the player only "touches" the ground every 3 frames
   and the position stutters slightly, which also trips up the grounded detection.
 -an epsilon should be close to the limit of float precision to avoid this.
   but it cannot be that small because then simply by moving 1000 blocks in one direction not the epsilon rounds to 0
   > not good
 -doubles would probably solve this issue even for far distances, but gpus do not support doubles usually so that is not an option
 -the only remaining solution is to have a "moving" origin, where the graphics and physics happens with these relative coords
   but the actual positions store an additional int to keep track of their real value
 -in this case of already having int indexes for blocks and floats for player, npcs etc. it is advantageous to just split the coords into block pos and fract pos with fract being a float
  -> floor(pos_world) reduces to pos_world.block > nice
  -> opengl matricies now need to store their coords relative to the player block, all block pos passed into shaders also need to get the player block substracted
  -> all fractional world positons need to use the new block_pos, fract_pos pair instead, which needs to wrap() its fract part and modify its block pos if the fract part moves wraps
  -> per frame you can simply work with this moving origin being constant, ie. use floats
   -> at the beginning of the frame a global block pos gets set as origin for that frame, coord->float just substracts that origin and float->coord adds it again,
      now this is almost automatic, you just need to make sure to not store float pos_worlds across frames because they get invalidated by the origin moving, just like an iterator into a vector gets invalidated by the vector expanding

 underwater fog

 reflections for water?
 -screenspace reflection
 
 look at COLLISION_SEPERATION_EPSILON, and if the raycast physics can live without it, being grounded should leave pos==block_top and vel.z==0

 even if getting stuck inside a block (which should be numerically impossible with a timestep of 0.05 as long as the integers are representable as floats (max would be 16,777,217))
  there should be a way of getting out of a block you are stuck in (since that should during gameplay), for example to fix being teleported into a wall or the ground
  allthough since you can break blocks, that might not be all that important
  getting out of deep inside a mountain should maybe not be possible
  but getting out of a wall you are only stuck in slightly should be possible
  maybe the physics does not let you enter blocks but once inside you get a force pushing you out and the collision does not stop you from exiting
  don't allow directed movement when in a wall or this might allow tunneling through walls
  a force might cause you to be flung away so the best way might just be:
   in the center of a block: stuck (no movement / "drowning" gameplay effect)
   you penetrate the wall by less than 0.5f block widths -> you are clearly on one side of the block, so just teleport you so you don't penetrate (player.pos -= pen_vector;)
   -> but only if the space you teleport to is free -> when stuck in completely solid rock you are stuck
 
 better third person camera object avoidance
 -camera should never clip into blocks! currently the camera focus point does not, but the near plane still goes into the block partly

 make a shader inspector in imgui that can edit shader code

 add shader directory change notify to reload all shaders that contain a changed file

IDEAS:
 voxel cone tracing for indirect lighting?
 -voxelize scene (no op for us, just need albedo for each voxel which is just it's avg texture color)
 -inject direct lighting -> torch light is already calculated in minecraft style light, sunlight should also be feasable even with a moving sun
 -filter down -> 8 voxels average down to 1 voxel to create "mipmaps", alpha could represent opacity
 -cone trace all surface faces
  -spawn a few cones at the surface, cone has a angle -> at dist x the radius is y -> sample the mipmap that best fits that radius
  -this way you prevent having N voxel samples for a NxNxN world, and instead have log N
  -the resulting sum of light now represent the indirect bounced light (just 1 bounce)
  -if that bounced light is now used as lighting of the voxel a second pass could add another bounce

 The only feasable way to render all chunks in one draw call i found is an extension for sparse vbos
 -allocate a vbo large enough for all possible chunks with each single face added in the mesh data
 -each chunk gets a slot in there
 -mesh data gets generated like usual, uploaded, the giant (100MB) slot for the chunk is mostly unused
 -but that is fine because the actual memory is virtualized and only the used pages are commited via the extension
 -indirect drawcalls can then be used to draw all the actual filled parts of the giant vbo

 explore ray marching for rendering:
 -no chunk meshes at all, gpu does ray marching
  -how is the complexity, performance and artifacting
 -feasable without octree?
  -performance difference with octree?
 -options: pixel shader, compute shader, opencl, cuda
  -> compute shader probably makes the most sense, but pixel shader might also be finde since i am basicly trying to display the image anyway
 -automatic order independent transparency!
 -reflections on water / glass

 instead of floating blocks everywhere create a basic structural simulation
 -minecraft proved that having large amounts of blocks be "falling blocks" (sand, eg. in desert) is possible
 -checks when blocks start falling just need to be limited
 -can this idea be extended to include checks along connected blocks, to see how "stable" they are?
 -stablity is at say 100 for fixed blocks and decreases for each block that is not fixed by some value depending on the block type
  (similar to how torch light falls off)
 -blocks with stablity 0 cannot be placed or just fall down (randomly maybe)
 -stablity could be visualized by having blocks "sag" with low stablity, ie. the mesher just shifts them down a bit
 -1 block wide towsers would still be 100% stable
  -maybe a noita-like system (the powder pixels) could be used so that falling blocks also randomly fall off the side of a block to form 






-OLD version:
 convert entire debug optios into new imgui way of doing things
 
 fix cut off trees
  -also do this for all 8 surrounding chunks no matter if the're generated or not
  -this way we can generate leaves in our chunks of trees in a neibouring chunk
 
 immediate mode debug shapes
 -arrow for velocity acceleration etc.
 -path drawing: object user can put outside of main loop -output one point each frame -> get line of last n points
 -> try to get rid of as much code in main loop as possible by turning player collision cylinder, etc. into code using this
 -maybe even integrate vector viewing into my imgui debug variables (allow visualizing any vector that gets displayed in the imgui)
 
 redesign input system
 
 improve block AO
 
 improve performance on notebook
 -chunk optimization ????
 
 blocks inventory (gain blocks on break and lose on place)
 
-BUGS:
